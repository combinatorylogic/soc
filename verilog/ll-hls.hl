% literate:

\section{HLS backend}

This is a very simple HLS backend for the LLVM IR generated by CLike frontend, to be
used alongside with the Verilog inlining experiments and Small$*$ SoC.

A C function is translated into a single FSM, in some cases, maybe, including
synthesised pipelines if it is possible to infer static loop properties (or if hinted
explicitly). Local arrays are translated into memories, and at the moment there is no
way to synthesise an access to an external memory bus (but should be relatively easy
to do).

\subsection{Outline}

Restrictions:

\begin{itemize}
\item Do not call things "clk", "reset", "ACK" and "REQ".
\item Do not call labels 'IDLE' and 'entry'.
\item Only array allocas are allowed (representing memories); Only GEPs over directly allocaded arrays are allowed - i.e., no registers storing pointers;
\item Only integer and integer pointer function arguments are allowed, with pointers representing outputs
\item Function must return void
\item No recursion, no non-intrinsic function calls. Everything is inlined
\end{itemize}

Output restrictions:

\begin{itemize}
\item Fully syncronous, single clock
\item Implicit clock, reset, req and ack signals
\end{itemize}

Translation:

\begin{itemize}
\item Code is translated into an FSM, initially by a direct mapping of basic blocks to states
\item Parallelism is exploited within a basic block level only. Later we'll try to split FSMs.
\end{itemize}


Translation pipeline:
\begin{itemize}
\item Generic SSA optimisations, with a twist: all the non-memory if branches are converted into selects.
\item Redundant GEPs must be eliminated in IR: {\sl (gep (alloca) 0 0)} and alike.
\item Within each basic block, split the entries into par and seq sub-blocks;
      Rules are following: same memory accesses are ordered (reads may be grouped), dependencies are obviously ordered, anything else is independent.

(Optional, to be done later) Order memory access smarter, e.g., group reads together and infer multi--port access.
\item (Optional, to be done later) identifying loops that can be turned into pipelines;
      If loop induction variables are "{\sl simple}" (whatever the fuck it means), internal sequence of par blocks
      may be converted into a detached pipeline, with induction variables being issued by a newly introduced FSM loop.
      Now back to our fucks: induction variables are {\sl simple} iff their loops are shorter than the loop body. E.g,
      a counter with loop invariant bounds is definitely {\sl simple}. For now, we will only do this transform for the
      loops that do not access the same memory in different stages. Later it may be possible to consider allowing something like
      a $2-$port read, $1-$port write scenario. We only do this for the innermost loops (TODO: why, actually?). All the pipeline stages
      must be strictly sequential basic blocks (i.e., all the internal branching is already resolved with selects).
      \begin{itemize}
        \item All pipeline stages are treated as one big par block, and are considered parallel with the control loop FSM stages.
        \item Also, this behaviour can be triggered explicitly with a pragma. Then, even if induction variables are not simple,
              a pipeline is still generated, with an output stored in a long vector instead (pipeline depth $=$ number of threads $=$ output width
              must be specified explicitly, because).
      \end{itemize}
\item Split basic blocks after the par blocks containing at least one delayed memory access operation.
\item Applying cost model to the sequential sub--blocks, breaking into smaller blocks if necessary.
\item Marking the SSA "registers" that are only used within their block (FSM stage) as wires, and
      persistent as "registers".
\item Cleanup stage --- if a register (as in register register, not just an SSA register, kinda) value is read in the same
      FSM stage, a wire value must be lifted and assigned both to the register and to its local uses.
\item (Optional) A possible optimisation - code motion from previous FSM steps/pipeline stages to reduce numbers of
      registers while maintaining the costs
\item Doing a register allocation to save area
\item Enumerating compute blocks that can be reused:
   \begin{itemize}
     \item For each par block, operations are enumerated; There is a budget for small adders and logical
           operations that are not counted (because cost of multiplexing ALU inputs/outputs would be higher than
           synthesising a small operation in place).
     \item A superposition of the operations of all the FSM stages are synthesised into one wide ALU block, with multiplexing
           inputs and outputs by the FSM stage number.
   \end{itemize}
\item (Optional) for the pipelines, infer pipeline registers (pass all the non--invariant values through all the stages down to
      their uses)
\item Converting small basic blocks to FSM/pipeline stages
\item Final code generation
\end{itemize}

\subsection{Intermediate ASTs}

\pfcode{
ast hls0 recform {
    top = module(ident:nm, *ram:rams, *modarg:args, *bblock:body);
    ram = r(ident:nm, type:t, *number:dims);
    modarg = ain(ident:nm, type:tp)
           | aout(ident:nm, type:tp)
           ;
    
    bblock = bb(bbtype:tp, label:name, *parblock:bs, exit:next);
    bbtype = pipeline(ident:id) | fsm(ident:id);
    parblock = pb(ident:name, *instr:ss, *ident:pars);
    instr = i(itp:tp,ident:dst, type:otp, iop:op);
    itp = none() | reg() | wire();          
    iop = load(ident:mem, value:offset)
        | store(ident:mem, value:offset, value:v)
        | op(ident:fn, *value:args)
        | convop(ident:fn, value:args, type:t)
        | select(value:cnd, value:tr, value:fl)
        | phi(*phiarg:args)
        | v(value:v) // it's not an SSA by now
        // After the split:
        | load_commit(ident:mem, ident:reg) // always assume a 1 cycle delay
        | load_start(ident:mem, ident:reg, value:offset)
        | op_commit(ident:reg, number:cycles)
        | op_start(ident:fn, *value:args)
        ;
    phiarg = p(ident:label, value:v);
    value = const(any:v, type:t)
          | undef(type:t)
          | reg(ident:id)
          ;
    type = v(number:bits);
    exit = br(label:dst) | brc(value:c, label:tr, label:fl) | switch(value:c, label:els, *switchdst:dsts)
         | ret()
         ;
    switchdst = d(value:v, label:dst); // value must be a constant
}}

\pfcode{
ast ir2mem : ir2 () {
   irexpr += mstore(ident:mem, irval:offset, irval:e)
           | mload(ident:mem, irval:offset)
           ;
}}


\pfcode{
%"ir2mem:irtype|integer.type -> integer; get type width in bits"
function ll_get_itype_width(type) {
   match type with
     'i32' -> 32
   | else -> 1
}}

\pfcode{
function ll_to_hls_gettype(t)
      visit:ir2mem (irtype:t) {
         deep irtype {
            integer -> with target(hls0) mk:type:v(ll_get_itype_width(type))
          | else -> ccerror('UNSUPPORTED_TYPE'(node))}}}

\subsection{Translation pipeline, part 1}

\pfcode{
%"ir2:irtoplevel -> ir2:irtoplevel; Remove redundant GEPs"
function ll_to_hls_prep_geps(top) {
   rewriteht = mkhash();
   rewrite(id0) =
     do loop(id = id0) {
       aif(chk = ohashget(rewriteht, id))
          visit:ir2(irval: chk) {
             deep irval { var -> loop(nm) | else -> node }}
       else 'var'(id)};
   iszerogep(idxs) =
     foldl(fun(x,y) (x && y), true,
             map i in idxs do
                visit:ir2 (irval: i) {
                  once irval {
                     integer -> if(v==0) true else []
                   | zero -> true
                   | else -> []}});
   prep() =
    visit:ir2 (irtoplevel: top) {
      deep irpair: e(nm);
      deep irexpr(dst) {
         getelementptr ->
            if (iszerogep(idxs)) ohashput(rewriteht, dst, ptr)
      | else -> []}};
   prep();
   return visit:ir2 (irtoplevel: top) {
      deep irval {
         var -> rewrite(nm)
       | else -> node};
      deep irpair: if (ohashget(rewriteht, nm)) [] else [node];
      deep irbblock {
         bblock -> mk:node(c = map append c do c)}}}}

\pfcode{
%"ir2:irtoplevel -> ht; Prepare the memories environment and check all the pointers"
function ll_to_hls_prep_memories(top)
collector(addram, getrams) {
  aenv = mkhash();
  // 1. Cache allocas
  isptr(t) =
    visit:ir2 (irtype: t) {
      once irtype {
        pointer -> t
      | else -> []}};
  getreg(v) =
    visit:ir2 (irval: v) {
      once irval {
        var -> nm
      | else -> []}};
  getwidth(t) =
    visit:ir2 (irtype: t) {
       once irtype {
          array -> [t;@dims]
       |  else -> ccerror('WRONG_ALLOCA'(t))}};
  visit:ir2 (irtoplevel: top) {
    deep irarg: {
       aif (ptype = isptr(type)) {
           w = 'output'(ptype);
           ohashput(aenv, name, w);
           addram([name;w]);
           ohashput(aenv, %Sm<<('PTR_', name), [name; 'integer'(0)])}
       };
    deep irpair: e(nm);
    deep irexpr(dst) {
       alloca -> {
           w = 'alloca'(@getwidth(t));
           addram([dst;w]);
           ohashput(aenv, dst, dst);
           ohashput(aenv, %Sm<<('PTR_', dst), [dst; 'integer'(0)])}
    |  else -> node}};
  // 2. Cache GEPs
  visit:ir2 (irtoplevel: top) {
    deep irpair: e(nm);
    deep irexpr(dst) {
       getelementptr -> {
         // Two things here: record the memory ID for this GEP, and
         // its offset calculation sequence, if any
         aif(mem = ohashget(aenv, getreg(ptr))) {
           // TODO: higher dimensions, structs, whatever
           ohashput(aenv, %Sm<<('PTRCALC_', dst), ['NONE']);
           ohashput(aenv, %Sm<<('PTR_', dst), [mem; car(idxs)]) // TODO: really?
         } else ccerror('ILLEGAL_GEP'(dst))}
     | else -> node}};
  ohashput(aenv, '*RAMS*', getrams());
  return aenv}}

\pfcode{
%"ir2:irbblock -> ir2mem:irbblock; explicit mstore and mload instructions"
function ll_to_hls_bb_memories(aenv, bb) {
   mems = mkhash();
   getoffval(nm) = {
      aif(r = ohashget(aenv, %Sm<<('PTRCALC_', nm))) {
        return cdr(r)
      } else ccerror('NOT_A_POINTER'(nm))};
   getmemoffv(nm) = {
      aif(r = ohashget(aenv, %Sm<<('PTR_', nm))) {
        <[mem;off]> = r;
        ohashput(mems, mem, mem);
        return r;
      } else ccerror('NOT_A_POINTER'(nm))};
   getmemoff(v) =
      visit:ir2 (irval: v) {
         once irval {
            var -> getmemoffv(nm)
          | else -> ccerror('UNSUPPORTED_PTR'(node))}};
   ret = visit:ir2 (irbblock:bb) {
      deep irexpr(dst) {
         store -> {
            <[mem;off]> = getmemoff(ptr);
            [[dst;'mstore'(mem, off, e)]]}
       | load -> {
            <[mem;off]> = getmemoff(ptr);
            [[dst;'mload'(mem, off)]]}
       | getelementptr -> getoffval(dst)
       | alloca -> []
       | else -> [[dst;node]]};
      deep irbblock {
         bblock -> mk:node(c = map append c do c)};
      deep irpair: e(nm)};
   memlist = hashmap(fun(k,v) k, mems);
   memorders = mkhash();
   iter m in memlist do ohashput(memorders, m, mkref([]));
   return memorders:ret}}

\pfcode{
function ll_to_hls_mkgraph() {mkhash():mkhash()}
function ll_to_hls_addnode(ordgraph, n) {
 <nodes:_> = ordgraph;
 ohashput(nodes, n, n)}
function ll_to_hls_addedge(ordgraph, f, t) {
 <_:edges> = ordgraph;
  prev = ohashget(edges, f);
  ohashput(edges, f, t:prev)}}

\pfcode{
%"ir2mem:irbblock -> []; order memory accesses for each lane separately"
function ll_to_hls_fill_memorder(ordgraph, memorders, bb) {
   memadd(dst, mem) = {
      prev = ohashget(memorders, mem);
      v = ^prev;
      prev := dst:v;
      if(v) {ll_to_hls_addedge(ordgraph, car(v), dst)}};
   visit:ir2mem (irbblock: bb) {
      deep irpair: e(nm);
      deep irexpr(dst) {
         mstore -> memadd(dst, mem)
       | mload -> memadd(dst, mem)
       | else -> []}}}}

\pfcode{
%"ir2mem:irbblock -> []; order register dependencies within this basic block"
function ll_to_hls_fill_deporder(ordgraph, bb) {
   vars = mkhash();
   // 1. Cache the registers defined in this block
   visit:ir2mem (irbblock: bb) {
      once irpair: ohashput(vars, nm, nm)};
   // 2. Add register dependencies to the graph, ignoring phis
   adddeps(dst, n) = {
      ll_to_hls_addnode(ordgraph, dst);
      visit:ir2mem (irexpr: n) {
         once irval {
            var -> if(ohashget(vars, nm)) ll_to_hls_addedge(ordgraph, nm, dst)
          | else -> []}}};
   visit:ir2mem (irbblock: bb) {
      deep irpair: e(nm);
      once irexpr(dst) {
         phi -> ll_to_hls_addnode(ordgraph, dst)
       | else -> adddeps(dst, node)
      }}}}

\pfcode{
function set_intersect(a, b)
collector(add, get) {
     ht = mkhash();
     iter a do ohashput(ht, a, a);
     iter b do if(ohashget(ht, b)) add(b);
     return get()}}

\pfcode{
%"ht -> [[nodes]...]; topological sort"
function ll_to_hls_sort_ordgraph(ordgraph) {
   // 1. Reverse the graph, find nodes with zero dependencies
   rev = ll_to_hls_mkgraph();
  <nodes:edges> = ordgraph;
   hashiter(fun(k,vs) iter v in vs do ll_to_hls_addedge(rev, v, k), edges);
  <_:revedges> = rev;
   // 1x. Full dependencies (there are no loops in this graph)
   fulldeps = mkhash();
   iter n in hashmap(fun(k,v)k, nodes) do {
     do loop0(deps = ohashget(revedges, n)) {
       if(deps) {
          ohashput(fulldeps, n, unifiq(deps::ohashget(fulldeps, n)));
          iter x in deps do loop0(ohashget(revedges, x))}}};
   seed = collector(addseed, getseed) {
      hashiter(fun(k, x) if (not(ohashget(revedges, k))) addseed(k), nodes);
      return getseed()};
   // 2. Breadth--first walking starting from the seed list
   collector(addpar, getpar) {
     do loop(f = seed) {
        if(f) addpar(f);
        next0 = unifiq(map append f do ohashget(edges, f));
        // eliminate the edges that depend on any other edges in this list
        next = filter l in next0 as not(set_intersect(next0, ohashget(fulldeps, l)));
        if(next) loop(next)};
     return getpar()}}}

\pfcode{
%"ir2:irbblock -> hls0:bb; Detect parallelism in a given basic block"
function ll_to_hls_bb_split(aenv, bb0, types) {
   // 1. Get a list of memories involved
  <memorders:bb> = ll_to_hls_bb_memories(aenv, bb0);
   // 2. Add memory access order, if any:
   //
   //    For each instruction in a bb, if it is a memory instruction, add it to
   //    the corresponding memory order lane.
   ordgraph = ll_to_hls_mkgraph();
   ll_to_hls_fill_memorder(ordgraph, memorders, bb);
   // 3. Add direct dependency order, if any (not counting phi depencencies)
   //
   //    For each instruction, add a destination dependency on its sources from the same basic block,
   //       unless it is a phi instruction, in this case do nothing.
   //
   ll_to_hls_fill_deporder(ordgraph, bb);
   // 4. Topological sort of the order graph
   parlists = ll_to_hls_sort_ordgraph(ordgraph);
   // 5. Emit a sequence of par blocks out of a sorted order graph (may result in a single large par block);
   //    Use this step to translate ir2 instructions, values, whatever to hls0.
   bit = with target(hls0) mk:type:v(1);
   mkconst(v, tp) = with target(hls0) mk:value:const(v, tp);
   mkundef(tp) = with target(hls0) mk:value:undef(tp);
   gettype(t) = ll_to_hls_gettype(t);
   gettype2(nm, t) =
      if(t) gettype(t) else bit;

   remove_allocas(b) =
      visit:ir2mem (irbblock: b) {
         deep irbblock {
            bblock -> mk:node(c = map append c do c)};
         deep irpair : e(nm);
         deep irexpr {
            alloca -> fun(dstreg) []
          | else   -> fun(dstreg) [[dstreg;node]]}};
   bb1 = remove_allocas(bb);
   return visit:ir2mem (irbblock: bb1) {
       deep irbblock {
          bblock ->
               with target(hls0) {
                  // 1. Cache the translated entries
                  entries = mkhash();
                  iter [nm;e] in c do
                     ohashput(entries, nm, e);
                  // Note the irony: an old AST visitor is building
                  //  a recform AST here, and it's a lot of boilerplate
                  mk:bblock:bb(tp = mk:fsm('default'),
                               name = name,
                               bs = map l in parlists do {
                                  // Name of the first entry in a par block is a name of this block,
                                  // just because.
                                  mk:pb(name = car(l), ss = map e in l do
                                                               mk:instr:i(mk:none(), e,
                                                                          gettype2(e, ohashget(types, e)),
                                                                          ohashget(entries, e)),
                                                       pars = [])},
                               next = t)}};
       deep irpair: [nm;e(nm)];
       deep irexpr(dst) {
          mstore -> with target(hls0) mk:iop:store(mem, offset, e)
        | mload  -> with target(hls0) mk:iop:load(mem, offset)
        | binary -> with target(hls0) mk:iop:op(op, [l;r])
        | convop -> with target(hls0) mk:iop:convop(op, v, gettype(t))
        | icmp   -> with target(hls0) mk:iop:op(vcond, [lhs;rhs])
        | phi    -> with target(hls0) mk:iop:phi(dsts)
        | select -> with target(hls0) mk:iop:select(vif, vthen, velse)
        | else   -> ccerror('UNSUPPORTED_INSTRUCTION'(node))};
       deep irphi : with target(hls0) mk:phiarg:p(dst, value);
       deep irval {
           false -> mkconst(0, bit)
        |  true  -> mkconst(1, bit)
        |  integer -> mkconst(v, with target(hls0) mk:type:v(ll_get_itype_width(itp)))
        |  undef -> mkundef(gettype(t))
        |  zero -> mkconst(0, gettype(t))
        |  var -> with target(hls0) mk:value:reg(nm)
        |  else -> ccerror('UNSUPPORTED_VALUE'(node))};
       deep irterm {
           vret -> with target(hls0) mk:exit:ret()
        |  br_label -> with target(hls0) mk:exit:br(nm)
        |  br -> with target(hls0) mk:exit:brc(cnd, tr, fl)
        |  switch -> with target(hls0) mk:exit:switch(value, els, cases)
        |  else -> ccerror('UNSUPPORTED_TERM'(node))};
       deep irswitchdst : with target(hls0) mk:switchdst:d(value, dst);
       }}}

Breaking basic blocks is a somewhat funny business, because we have phis that must be updated any time something happens to any
of the incoming blocks. For this reason, we must implement a generic basic block breaking tool first (similar to the genssa one).

\pfcode{
function ll_to_hls_get_op_cost(fn, dst, args) {
   // TODO: the real cost model, not this half assed shit
   case (fn) {
     'Shl' | 'AShr' | 'LShr' -> 0
   | 'NOT' -> 1+(dst/3)
   | 'EQ' | 'NE' | 'SGE' | 'SLT' -> 1 + (dst/2)
   | else -> dst
   }}}

\pfcode{
// TODO: some meaningful numbers + a user-controlled target (or maybe even
//       a feedback loop with the post place-and-route timing)
define ll_to_hls_cost_threshold = 64

%"hls0:bb -> *hls0:bb; Assess block timing costs"
function ll_to_hls_bb_costmodel(aenv, bb, regtypes) {
  // 1. Calculate the maximum cost of par block elements
  max2(a,b) = if(a>b) a else b;
  getregtype(id) = {
    aif(chk = ohashget(regtypes, id)) {
      visit:hls0 /rec/ (type: chk) {
        deep type { v -> bits}}}
    else 1};
  costs = visit:hls0 /rec/ (bblock: bb) {
    deep bblock { bb -> bs };
    deep parblock { pb -> name:foldl(max2, 0, ss) };
    deep instr { i -> op(otp) };
    deep iop(otp) { op -> ll_to_hls_get_op_cost(fn, otp, args) | else -> 0 };
    deep type { v -> bits };
    deep value { const -> t | undef -> t | reg -> getregtype(id) }};
  // 2. For any block sequence above the given cost,
  //    add a break (an implicit FSM stage)
  collector(addbreak, getbreaks) {
    do loop(c = costs, acc = 0) {
       match c with
        (pb:w):rest -> if ((acc + w) > ll_to_hls_cost_threshold)
                          {addbreak(pb); loop(rest, 0)}
                       else loop(rest, acc + w)};
    return getbreaks()}}}

\pfcode{
function ll_to_hls_cache_regtypes(top) {
  regs = mkhash();
  addreg(nm, tp) = ohashput(regs, nm, tp);
  visit:hls0 /rec/ (top: top) {
    deep modarg {
       ain -> addreg(nm, tp) | aout -> addreg(nm, tp)};
    deep instr {
       i -> addreg(dst, otp) }};
  return regs}}

\pfcode{
function ll_to_hls_apply_breaks(aenv, top, breaks)
collector(addbb, getbbs) {
   // 1. Cache breaks
   lastbbs = mkhash(); breaksht = mkhash();
   iter break(bb, pbs) in breaks do {
      newpbs = map p in pbs do (p:gensym());
     <[(_:lastbb)]> = lasttail(newpbs);
      ohashput(lastbbs, bb, lastbb);
      ohashput(breaksht, bb, newpbs)};
   // 2. Utility
   rewritephisrc(lbl) =
     aif(chk = ohashget(lastbbs, lbl)) chk else lbl;
   getpbname(pb) =
     visit:hls0 /rec/ (parblock: pb) { once parblock { pb -> name }};
   flushbb(bbtp,bs, nm, nxt) = with target(hls0) {
     addbb(mk:bblock:bb(name = nm, tp = bbtp, bs = bs, next = mk:br(nxt)))};
   dosplitbb(name, bbtp, lst, bs) =
     do loop(l = lst, b = bs, acc = [], cur = name) {
         match [l;b] with
            [(pnm:newbb):rest;
             pb:pbrest] -> {
               if(pnm === getpbname(pb)) {
                 flushbb(bbtp, acc, cur, newbb);
                 loop(rest, pbrest, [pb], newbb)
               } else loop(l, pbrest, acc::[pb], cur)}
          | else -> return acc::b};
   rewritebb(name, bb) = {
     aif(lst = ohashget(breaksht, name)) {
       visit:hls0 /rec/ (bblock: bb) {
         deep bblock {
           bb -> {
              lastpbs = dosplitbb(name, tp, lst, bs);
              lastname = ohashget(lastbbs, name);
              addbb(mk:node(name = lastname, bs = lastpbs))
           }}}
     } else addbb(bb)};
   // 3. Rewrite
   visit:hls0 /rec/ (top: top) {
      deep phiarg { p -> mk:node(label = rewritephisrc(label)) };
      deep bblock { bb -> rewritebb(name, node()) };
      deep top { module -> mk:node(body = getbbs()) }}}}

\pfcode{
function ll_to_hls_costmodel(aenv, top)
collector(add, get) {
  regs = ll_to_hls_cache_regtypes(top);
  addbreaks(bb, bs) = if(bs) add('break'(bb, bs));
  visit:hls0 /rec/ (top: top) {
     once bblock { bb -> {
        breaks = ll_to_hls_bb_costmodel(aenv, node(), regs);
        addbreaks(name, breaks)}}};
  breaks = get();
  if (breaks)
     ll_to_hls_apply_breaks(aenv, top, breaks)
  else top}}


\pfcode{
function ll_to_hls_split_loads(aenv, top) {
   // 1. For each basic block containing a load instruction inside its last parblock,
   //    insert an empty additional parblock for a further breaking.
   isloadpb(lb) = {
      loadp = mkref([]);
      visit:hls0 /rec/ (parblock: lb) {
        deep iop { load -> {loadp := true} | store -> {loadp:=true} | else -> []}};
      return ^loadp};
   insemptypbs(t) =
     visit:hls0 /rec/ (top: top) {
       deep bblock {
          bb -> if (bs) {
             lb = car(lasttail(bs));
             if(isloadpb(lb)) {
                mk:node(bs = bs :: [mk:parblock:pb(name = gensym(), ss=[], pars=[])])
             } else node()
          } else node()}};

   top1 = insemptypbs(top);

   // 2. Break after every parblock containing a load instruction.
   //    Some previous optimisations may ensure that loads are always as close to
   //    their uses as possible (TODO: is it the optimal solution?)
   //    Also, use this opportunity to pre-fill the next parblocks hash.
   nextpbs = mkhash();
   makebreaks(t, addbr) = 
      visit:hls0 /rec/ (top: t) {
         deep bblock {
            bb -> collector(addx, getx) {
               rbs = reverse(bs);
               foldl(fun(prevname, p) {
                      <[nm;ldp]> = p;
                       ohashput(nextpbs, nm, prevname);
                       if(ldp) addx(prevname);
                       return nm
                     }, '_', rbs);
               n = getx();
               if(n) addbr('break'(name, reverse(n)))}};
         deep parblock { pb -> [name; isloadpb(node())] }};
   breaks = collector(addbr, getbr) {
      makebreaks(top1, addbr);
      return getbr()};
   top2 = if(breaks) ll_to_hls_apply_breaks(aenv, top1, breaks) else top1;
   // 3. Replace each load with a load_start, assigning it to a dummy variable.
   //    Insert a load_commit operation into the next bb, marking it with the same memory id and
   //    the same dummy variable (will need this later for the multi-port memories).
   splitloads(t) = {
      // 1. Collect the loads, give them new names
      loads = mkhash();
      renameloads(t0) = 
         visit:hls0 /rec/ (top: t0) {
            deep parblock { pb -> mk:node(ss = map s in ss do s(name)) };
            deep instr(pbnm) { i -> op(pbnm, dst, otp, 
                                       fun(newnm, newop) {
                                          mk:node(dst = newnm, op = newop)}) };
            deep iop(pbnm, dst, otp, mki) {
               load -> { newnm = gensym();
                         nextpb = ohashget(nextpbs, pbnm);
                         ohashput(loads, nextpb, [dst;newnm;otp;mem]:ohashget(loads, nextpb));
                         return mki(newnm, mk:load_start(mem, newnm, offset)) }
             | else -> return mki(dst, node())}};
      nt = renameloads(t);
      // 2. Insert load_commit instructions
      return visit:hls0 /rec/ (top: nt) {
         deep parblock {
            pb -> aif(chk = ohashget(loads, name)) {
               mk:node(ss = (map [dst;newnm;ltp;mem] in chk do {
                               mk:instr:i(mk:none(), dst, ltp, mk:load_commit(mem, newnm))
                             }) :: ss)
            } else node()}}};

   return splitloads(top2)
}}

\pfcode{
%"hls0:top -> hls0:top; Infer the registers"
function ll_to_hls_mark_registers(aenv, top) {
  // Mark all the SSA registers that are used in another basic block
  //   or in a phi node as persistent registers.

  // 1. Cache the register origin bblock (FSM stages by now)
  origs = mkhash();
  setorigin(bb, reg) = ohashput(origs, reg, bb);
  prep() = 
   visit:hls0 /rec/ (top: top) {
     deep bblock {
        bb -> iter b in bs do b(name)};
     deep parblock(bb) {
        pb -> iter s in ss do s(bb)};
     deep instr(bb) {
        i -> setorigin(bb, dst)}};
  prep();

  // 2. Mark registers used outside of their origin stage or in
  //    a phi node of any stage
  regs = mkhash(); noeffect = mkhash();
  setreg(nm) = ohashput(regs, nm, nm);
  setnoeff(nm) = ohashput(noeffect, nm, nm);
  markphi(nd) =
    visit:hls0 /rec/ (iop: nd) {
       deep value {
          reg -> setreg(id) | else -> []}};
  markall(bb, nd) =
    visit:hls0 /rec/ (iop: nd) {
       deep value {
          reg -> if (not(ohashget(origs, id)===bb)) setreg(id)}};
  markregs() = 
    visit:hls0 /rec/ (top: top) {
     deep bblock {
        bb -> iter b in bs do b(name)};
     deep parblock(bb) {
        pb -> iter s in ss do s(bb)};
     deep instr(bb) {
        i -> op(dst, bb)};
     deep iop(dst, bb) {
        phi -> markphi(node())
      | store -> setnoeff(dst)
      | load_start -> setnoeff(dst)
      | else -> markall(bb, node())}};
  markregs();
  // 3. Rewrite
  return visit:hls0 /rec/ (top:top) {
     deep instr {
        i -> if(ohashget(regs, dst))
               mk:node(tp = mk:reg())
             else if(ohashget(noeffect, dst))
               mk:node(tp = mk:none())
             else
               mk:node(tp = mk:wire())}}}}

\pfcode{
function ll_to_hls_mark_output(aenv, top) {
   isoutput(id) = {
      aif(chk = ohashget(aenv, id)) {
        match chk with
           'output'(x) -> ll_to_hls_gettype(x)
         | else -> []} else []};
   visit:hls0 /rec/ (top: top) {
      deep instr {
         i -> op(otp, thisnodesrc())};
      deep iop(otp, up) {
         store -> 
            aif(notp = isoutput(mem)) {
               mk:instr:i(mk:reg(), mem, notp, mk:v(v))
            } else up
       | else -> up}}}}

\pfcode{
function ll_to_hls_lift_wires_bb(bb) {
  rewrites = mkhash(); rewrite(id) = aif(chk = ohashget(rewrites, id)) chk else id;
  pass1() =
   visit:hls0 /rec/ (bblock: bb) {
     deep parblock {
       pb -> mk:node(ss = map append s in ss do s)};
     deep instr {
       i -> tp(dst, otp, op)};
     deep itp(dst, otp, op) {
       reg -> symbols(newnm) {
          ohashput(rewrites, dst, newnm);
          [mk:instr:i(mk:wire(), newnm, otp, op);
           mk:instr:i(mk:reg(), dst, otp, mk:v(mk:reg(newnm)))]}
      | else -> [mk:instr:i(thisnodesrc(), dst, otp, op)]}};
  // We have to do it in two passes here, because it's possible to use
  // a register before it's lifted to a wire within one basic block.
  visit:hls0 /rec/ (bblock: pass1()) {
     deep value {
        reg -> mk:reg(rewrite(id))
      | else -> node()}}}}

\pfcode{
%"hls0:top -> hls0:top; A temporary (simple) solution:
  lift all the register assignments as wires and use these wires in the same fsm stage"
function ll_to_hls_lift_wires(top)
  visit:hls0 /rec/ (top: top) {
    once bblock { else -> ll_to_hls_lift_wires_bb(node()) }}}


We still allow phis here, they are going to be resolved as the very last step (either by small origin registers + muxes, or by fusing
registers).

\subsection{Next stage intermediate AST}

\pfcode{
ast hls1 : hls0 () recform {
   top = module(ident:nm, *ram:rams, *modarg:args, *modentry:es);
   modentry = fsm(ident:nm, ident:start, *fsmstage:ss)
            | register(type:t, ident:nm)
            | wire(type:t, ident:nm)
            | assign(ident:nm, value:v)
            //TODO:
            // | pipeline(ident:nm, *pipestage:ss)
            ;
   fsmstage = stage(label:name, *instr:ss, exit:next);
   instr = a(ident:reg, type:otp, iop:op) | z(iop:op);
   expr = 
          op(ident:fn, *value:args)
        | convop(ident:fn, value:args, type:t)
        | select(value:cnd, value:tr, value:fl)
        | nphi(ident:fsm, ident:stage, *phiarg:args)
        | v(value:v)
        | load_commit(ident:mem, ident:reg)
        ;
   iop += nphi(ident:fsm, ident:stage, *phiarg:args)
       |  -phi
       |  -load
       ;
   // Nesting is ok at the later stages (e.g., phi elimination)
   value += e(expr:e);
}}


\subsection{Translation pipeline, part 2}

\pfcode{
%"hls0:top -> hls1:top; Make our FSMs explicit"
function ll_to_hls_explicit_fsms(aenv, top) {
   // 1. Previous steps could have splitted FSMs into multiple parallel
   //    flows, here we have to collect BBs from the different FSMs.
   fsms = mkhash();
   collectfsms() =
     visit:hls0 /rec/ (top: top) {
       deep bblock {
          bb -> tp(thisnodesrc())};
       deep bbtype(bb) {
          fsm -> ohashput(fsms, id, bb:ohashget(fsms, id))
        | else -> []}};
   collectfsms();
   // 2. Lift all the declarations. N.b. that this is not an SSA any more after
   //    the register allocation, and one register can be assigned more than once.
   decls = collector(adddecl, getdecls) {
     regs = mkhash();
     liftdecl(k, id, rtp) =
       with target(hls1) {
          if(k==='reg')
             adddecl(mk:modentry:register(rtp, id))
          else adddecl(mk:modentry:wire(rtp, id));
          if(k==='reg') ohashput(regs, id, id)};
     collectdecls() =
        visit:hls0 /rec/ (top: top) {
           deep instr {
              i -> tp(dst, otp)};
           deep itp(id, rtp) {
              reg -> if (not(ohashget(regs, id))) liftdecl('reg', id, rtp)
            | wire -> liftdecl('wire', id, rtp)}};
     collectdecls();
     return getdecls()};
   // 3. Generate FSM stages, leaving only the register transfers and
   //    memory stores inside. The rest is lifted as combinational logic.
   //    N.b.: phis are lifted too, unless they're assigned to registers with
   //    no immediate use, and an fsm+stage info is attached to make it easier to
   //    replace them with muxes later.
   collector(addfsm, getfsms) {
   collector(addass, getasss) {
     makeassign(fsm, stage, nd) = 
       visit:hls0 /rec, dst hls1/ (instr: nd) {
         deep instr {
           i -> addass(mk:modentry:assign(dst, mk:e(op(dst))))};
         deep iop(wire) {
           op -> mk:expr:op(fn, args)
         | convop -> mk:expr:convop(fn, args, t)
         | select -> mk:expr:select(cnd, tr, fl)
         | phi    -> mk:expr:nphi(fsm, stage, args)
         | v      -> mk:expr:v(v)
         | load_commit -> mk:expr:load_commit(mem, reg)
         | else   -> ccerror('CANNOT_BE_WIRE'(wire))
         }};
     makeinstr(fsm, stage, nd) =
       visit:hls0 /rec, dst hls1/ (instr: nd) {
          deep iop {
             phi -> mk:iop:nphi(fsm, stage, args)
           | else -> node()};
          deep instr {
             i -> mk:instr:a(dst, otp, op)}};
     makezinstr(nd) =
       visit:hls0 /rec, dst hls1/ (instr: nd) {
          deep instr {
             i -> mk:instr:z(op)}};
     rewritebb(fsmname, bb) = 
       visit:hls0 /rec, dst hls1/ (bblock: bb) {
         deep bblock {
           bb -> mk:fsmstage:stage(name, map append b in bs do b(name), next)};
         deep parblock(stagename) {
           pb -> map append s in ss do s(stagename)};
         deep instr(stagename) {
           i -> tp(stagename, thisnodesrc())};
         deep itp(stagename, nd) {
           reg -> [makeinstr(fsmname, stagename, nd)]
         | none -> [makezinstr(nd)]
         | else -> {makeassign(fsmname, stagename, nd);[]}}};
     hashiter(fun(fsmnm, lst) {
                 ss = map bb in reverse(lst) do
                        rewritebb(fsmnm, bb);
                 with target(hls1) {
                   addfsm(mk:modentry:fsm(fsmnm, 'entry', ss))
                 }}, fsms);
     return visit:hls0 /rec, dst hls1/ (top: top) {
       once top {
         module -> mk:top:module(es = decls :: getasss() :: getfsms())}}}}}}

\pfcode{
%"hls1:top -> hls1:top; replace phis with selects"
function ll_to_hls_remove_phis(top) {
  // 1. Collect state transitions that are leading to phis
  fsms = mkhash();
  getfsm(id) =
    aif(arcs = ohashget(fsms, id)) arcs
    else {
       arcs = mkhash();
       ohashput(fsms, id, arcs);
       return arcs};
  collectphis() = {
     addphi(fsm, stage, args) = {
        arcs = getfsm(fsm);
        iter a in args count n do 
           ohashput(arcs, a, [stage; n]:ohashget(arcs, a))};
     visit:hls1 /rec/ (top: top) {
        deep iop { nphi -> addphi(fsm, stage, args) | else -> []};
        deep expr { nphi -> addphi(fsm, stage, args) | else -> []};
        deep phiarg { p -> label }}};
  collectphis();

  // 1x. Collect exits
  exits = mkhash();
  collectexits() =
     visit:hls1 /rec/ (top: top) {
        deep modentry {
           fsm -> iter ss do ss(nm)
         | else -> []};
        deep fsmstage(fsmname) {
           stage -> next(fsmname, name)};
        deep exit(fsm, stage) {
           else -> ohashput(exits, %Sm<<(fsm, "--", stage), node())}};
  collectexits();

  // 2. Create a branch id register for each FSM, with enough bits to
  //    represent the largest phi in it.
  fsmregs = mkhash();
  hashiter(fun(k, v) ohashput(fsmregs, k, gensym()), fsms);

  // 3. Inject register assignments to the originating sstates and
  //    replace phi nodes with selects
  getfsmreg(fsm) = ohashget(fsmregs, fsm);
  etype = with target (hls1) { mk:type:v(0) }; // TODO
  injectexits(fsm, stage, regname, phiarcs) = with target (hls1) {
     next = ohashget(exits, %Sm<<(fsm, "--", stage));
     nxts = mkhash(); getn(l) = aif(chk = ohashget(nxts, l)) chk else 0;
     getnc(l) = with target(hls1) { mk:value:const(getn(l), etype)};
     iter [f;n] in phiarcs do ohashput(nxts, f, n);
     [mk:instr:a(regname, etype,
       visit:hls1 /rec/ (exit: next) {
          deep exit {
             br -> mk:iop:v(getnc(dst))
           | brc -> mk:iop:select(c, getnc(tr), getnc(fl))
           | switch -> mk:iop:op('nselect', [c;@map d in dsts do getnc(d)])
           | else -> ccerror('IMPOSSIBLE'())}})]};
  inject(fsm, stage) = {
     arcs = getfsm(fsm);
     phiarcs = ohashget(arcs, stage);
     if (phiarcs) {
       regname = getfsmreg(fsm);
       return injectexits(fsm, stage, regname, phiarcs);
     } else []};
  expandphi(fsm, stage, args) =
    with target(hls1){
       regname = getfsmreg(fsm);
       do loop(a = args, cnt = 0) {
         match a with
            [hd] -> hd
          | hd:tl -> mk:expr:select(mk:e(mk:op('EQ', [mk:reg(regname); mk:const(cnt, mk:v(0))])),
                                    hd, loop(tl, cnt+1))}};
  return visit:hls1 /rec/ (top: top) {
     deep top {
        module -> {
          // TODO: infer origin register widths
          newregs = hashmap(fun(k, nm) {mk:modentry:register(mk:v(32),nm)}, fsmregs);
          mk:node(es = newregs :: es)}};
     deep modentry {
        fsm -> mk:node(ss = map s in ss do s(nm))
      | else -> node()};
     deep fsmstage(fsmname) {
        stage -> { inj = inject(fsmname, name); mk:node(ss = ss :: inj) }};
     deep expr {
        nphi -> expandphi(fsm, stage, args)
      | else -> node()};
     deep phiarg { p -> v };
     deep iop {
        nphi -> mk:v(mk:e(expandphi(fsm, stage, args)))
      | else -> node()}}}}


\subsection{Further lowering}

\pfcode{
ast hls2 : hls1() recform {
   fsmstage = stage(label:name, *stmt:body);
   modentry += xfsm(ident:nm, label:start, stmt:reset, *fsmstage:ss)
            |  -fsm;
   expr += -nphi
        ;
   stmt = begin(*stmt:ss)
        | if(expr:e, stmt:tr, stmt:fl)
        | goto(label:stage)
        | switch(expr:id, stmt:dflt, *case:cs)
        | set(ident:reg, expr:v)
        | store(ident:mem, expr:idx, expr:v)
        | load_start(ident:mem, ident:reg, expr:off)
        ;
   case = d(value:v, stmt:s);
}}

\pfcode{
function ll_to_hls_lower_hls1(top) {
   bit = with target(hls2) {mk:type:v(1)};
   zero = with target(hls2) {mk:value:const(0, bit)};
   one = with target(hls2) {mk:value:const(1, bit)};
   dofsm(f) =
      {
         // 1. Collect registers to fill a reset statement.
         fsmregs = collector(addreg, getregs) {
            collectregs() =
               visit:hls1 /rec/ (modentry: f) {
                  once instr {
                     a -> addreg(reg) | else -> []}};
            collectregs();
            return unifiq(getregs())};
         // 2. Prepare a reset statement and an idle stage:
         // TODO: only set ACK for the 'default' FSM, the others
         //       should not drive it.
         reset = with target(hls2) {
          mk:stmt:begin(
            [mk:stmt:set('ACK', mk:v(zero));
             @map r in fsmregs do
               mk:stmt:set(r, mk:v(zero))])};
         makeidle(start) =
            with target(hls2) {
               mk:fsmstage:stage('IDLE', [
                                          mk:set('ACK', mk:v(zero));
                                          mk:if(mk:op('EQ',[mk:reg('REQ');one]), mk:stmt:goto(start),
                                                mk:stmt:goto('IDLE'))])};
         // 3. Rewrite an FSM
         visit:hls1 /rec, dst hls2/ (modentry: f) {
            deep modentry {
              fsm -> mk:modentry:xfsm(nm, 'IDLE', reset, makeidle(start): ss)
            | else -> ccerror('WTF'())};
            deep fsmstage {
              stage -> mk:fsmstage:stage(name, ss :: next)};
            deep instr {
              a -> mk:stmt:set(reg, op)
            | z -> op};
            deep iop {
              store -> mk:stmt:store(mem, mk:v(offset), mk:v(v))
            | load_start -> mk:stmt:load_start(mem, reg, mk:v(offset))
            | op -> mk:expr:op(fn, args)
            | convop -> mk:expr:convop(fn, args, t)
            | select -> mk:expr:select(cnd, tr, fl)
            | nphi -> ccerror('IMPOSSIBLE'())
            | v -> mk:expr:v(v)};
            deep switchdst {
              d -> mk:case:d(v, mk:stmt:goto(dst))};
            deep exit {
              br -> [mk:stmt:goto(dst)]
            | brc -> [mk:stmt:if(mk:v(c), mk:stmt:goto(tr), mk:stmt:goto(fl))]
            | switch -> [mk:stmt:switch(mk:v(c), mk:stmt:goto(els), dsts)]
            | ret -> [mk:stmt:set('ACK', mk:v(one)); mk:stmt:goto('IDLE')]}}};
   // Process FSMs
   visit:hls1 /rec, dst hls2/ (top: top) {
      deep top {
         module -> mk:top:module(args = args :: [mk:modarg:ain('REQ', bit);
                                                 mk:modarg:aout('ACK', bit)])};
      once modentry {
         fsm -> dofsm(node())
       | deep -> { else -> node() }}}}}


\pfcode{litinclude ("../doc/ll-hls-regalloc") "./ll-hls-regalloc.hl"}

\subsection{Test driver}


\pfcode{
ast hls3 : hls2 () recform {
   modentry += always(stmt:s)
               // TODO: multiport RAMs
            |  ram(ident:id, number:w, number:size,
                   value:readaddr1, value:readout1,
                   value:writeaddr1, value:writein1, value:we)
            |  -xfsm
            ;
   expr += isfsmstage(ident:fsmname, ident:stage)
        |  selectchain(*selectelt:es)
        ;
   stmt += nop()
        | store_x(ident:stagereg, value:stage, ident:mem, expr:idx, expr:v)
        | load_start_x(ident:stagereg, value:stage,
                       ident:mem, ident:reg, expr:off)
        ;
   selectelt = e(value:c, value:v);
}}

\pfcode{
function ll_to_hls_lower_fsm(top) {
  dofsmbody(stagereg, tp, ssmap, body) = {
     dofsmstage(thisstage, s) = {
       visit:hls3 /rec/ (stmt: s) {
          deep stmt {
             goto -> mk:set(stagereg, mk:v(mk:const(ohashget(ssmap, stage), tp)))
           | load_start -> mk:stmt:load_start_x(stagereg = stagereg, stage=thisstage)
           | store -> mk:stmt:store_x(stagereg = stagereg, stage=thisstage)
           | else -> node()}}};
     visit:hls3 /rec/ (case: body) {
        once case {
           d -> mk:node(s = dofsmstage(v, s))}}};
  bit = with target (hls3) {mk:type:v(1)};
  visit:hls2 /rec, dst hls3/ (top: top) {
     deep top {
        module -> mk:module(args = [mk:ain('clk',bit);
                                    mk:ain('reset',bit);
                                    @args],
                            es = map append es do es)};
     deep fsmstage {
        stage -> [name;
                  fun(idx, tp) {
                    mk:case:d(mk:const(idx,tp), mk:begin(body))}]};
     deep modentry {
        xfsm -> collector(addm, getm) {
                  stagereg = gensym();
                  ssmap = mkhash();
                  iter [nm;body] in ss count i do
                               ohashput(ssmap, nm, i);
                  nstages = length(ss);
                  nbits = /*TODO!!!*/ 32;
                  nbitstp = mk:type:v(nbits);
                  addm(mk:modentry:register(nbitstp, stagereg));

                  fsmreset = mk:stmt:begin([
                                  mk:set(stagereg, mk:v(mk:const(0, nbitstp)));
                                  reset
                             ]);
                  fsmbody = map [nm;body] in ss do
                                dofsmbody(stagereg, nbitstp, ssmap,
                                          body(ohashget(ssmap, nm), nbitstp));
                  ret = mk:modentry:always(
                              mk:if(mk:op('NOT',[mk:reg('reset')]),
                                    fsmreset,
                                    mk:switch(mk:v(mk:reg(stagereg)), mk:begin([]),
                                              fsmbody)
                                    ));
                  return [@getm(); ret]}
      | else -> [node()]};
  }}}


\pfcode{
function ll_to_hls_lower_mems(aenv, top) {
  // 1. Collect allocas from the *RAMS* list.
  //    Lift the address, value and WE wires.
  //    Lift the ram instances
  rs = map append r in ohashget(aenv, '*RAMS*') do
          match r with
             [id; alloca(tp, sz)] -> [[id; sz; ll_to_hls_gettype(tp)]]
           | else -> [];
  i32 =  with target (hls3) {mk:type:v(32)};
  ramsh = mkhash();
  getsize(t) = visit:hls3 /rec/ (type: t) {once type { v -> bits }};
  newtops = collector(addelt, getelts) {
    iter [id;sz;w] in rs do with target (hls3) {
       readaddr1 = gensym();
       readout1 = gensym();
       writeaddr1 = gensym();
       writein1 = gensym();
       we = gensym();
       ohashput(ramsh, id, [[w; i32]; [readaddr1; readout1]; [writeaddr1; writein1]; we]);
       addelt(mk:modentry:wire(w, readout1));
       addelt(mk:modentry:wire(w, writein1));
       // TODO: calculate address bit width
       addelt(mk:modentry:wire(i32, readaddr1));
       addelt(mk:modentry:wire(i32, writeaddr1));
       addelt(mk:modentry:wire(mk:v(1), we));
       addelt(mk:modentry:ram(id, getsize(w), sz,
                     mk:reg(readaddr1),
                     mk:reg(readout1),
                     mk:reg(writeaddr1),
                     mk:reg(writein1),
                     mk:reg(we)));
    };
    return getelts()};
  // 2. Collect _start operations, assuming there is only one in each fsm stage.
  collectstarts(t) = collector(addx, getx) {
     visit:hls3 /rec/ (top: t) {
        deep stmt {
             load_start_x -> addx('load'(stagereg, stage, mem, reg, off))
           | store_x -> addx('store'(stagereg, stage, mem, idx, v))
           | else -> []}};
     return getx()};
  ss = collectstarts(top);
  ramaddrs = mkhash(); ramwes = mkhash();
  newtops1 = collector(addt, getts) {
     iter r in ss do with target(hls3) {
       match r with
          load(stagereg, stage,mem,reg, off) -> {
            <[[w; wa]; [readaddr1; readout1]; [writeaddr1; writein1]; we]> = ohashget(ramsh, mem);
             addt(mk:modentry:wire(wa, reg));
             addt(mk:modentry:assign(reg, mk:e(off)));
             ohashput(ramaddrs, mem, [stagereg;stage;reg]:ohashget(ramaddrs, mem));
          }
        | store(stagereg, stage, mem, idx, v) -> {
            <[[w; wa]; [readaddr1; readout1]; [writeaddr1; writein1]; we]> = ohashget(ramsh, mem);
             reg = %Sm<<(gensym(), "_", mem);
             regaddr = %Sm<<(reg, "_addr");
             regvin  = %Sm<<(reg, "_vin");
             addt(mk:modentry:wire(wa, regaddr));
             addt(mk:modentry:wire(w, regvin));
             addt(mk:modentry:assign(regaddr, mk:e(idx)));
             addt(mk:modentry:assign(regvin, mk:e(v)));
             ohashput(ramwes, mem, [stagereg; stage;regaddr;regvin]:ohashget(ramwes, mem))}};
     return getts()};
  // 3. Lift the assign statements mux-ing addresses and values on the FSM stages.
  newtops2 = collector(addt, getts) {
     hashiter(fun (mem, xs) with target(hls3) {
                rs = map [stagereg;stage;reg] in xs do {
                   mk:selectelt:e(
                    mk:value:e(mk:expr:op('EQ', [mk:reg(stagereg);stage])),
                    mk:value:reg(reg))};
               <[[w; wa]; [readaddr1; readout1]; [writeaddr1; writein1]; we]> = ohashget(ramsh, mem);
                addt(mk:modentry:assign(readaddr1, mk:value:e(mk:selectchain(rs))))
              }, ramaddrs);
     return getts()};
  newtops3 = collector(addt, getts) {
       hashiter(fun (mem, xs) with target(hls3) {
                   bit = mk:type:v(1);
                   zeroop = mk:selectelt:e(mk:const(1, bit), mk:const(0, bit));
                   rs0 = map [stagereg; stage; regaddr; regvin] in xs do {
                           op = mk:value:e(mk:expr:op('EQ', [mk:reg(stagereg);stage]));
                           [mk:selectelt:e(op, mk:value:reg(regaddr));
                            mk:selectelt:e(op, mk:value:reg(regvin));
                            mk:selectelt:e(op, mk:const(1, bit))]};
                   rs = map [a;b;c] in rs0 do a;
                   vs = map [a;b;c] in rs0 do b;
                   ws = map [a;b;c] in rs0 do c;
                  <[[w; wa]; [readaddr1; readout1]; [writeaddr1; writein1]; we]> = ohashget(ramsh, mem);
                   addt(mk:modentry:assign(writeaddr1, mk:value:e(mk:selectchain(rs))));
                   addt(mk:modentry:assign(writein1,   mk:value:e(mk:selectchain(vs))));
                   addt(mk:modentry:assign(we,         mk:value:e(mk:selectchain(ws::[zeroop]))))},
                ramwes);
     return getts()};
  // TODO: same shit for the stores
  
  // 4. Rewrite the rest, removing all the _start operations and replacing _commits with
  //    the corresponding output wires.
  visit:hls3 /rec/ (top: top) {
     deep top {
        // TODO: reorder, add after all the existing wires
        module -> mk:node(es = newtops ::  newtops1 ::  newtops2 :: newtops3 :: es)};
     deep stmt {
        load_start_x -> mk:nop()
      | store_x -> mk:nop()
      | else -> node()};
     deep expr {
        load_commit -> {
          <[[w; wa]; [readaddr1; readout1]; [writeaddr1; writein1]; we]> = ohashget(ramsh, mem);
           return mk:v(mk:reg(readout1))}
      | else -> node()}}}}


\pfcode{
function ll_to_hls3_sort_decls(top) {
  // Move all the regs and wires above all the assignments, rams and always
  collector(addregwire, getregwires)
  collector(addram, getrams)
  collector(addass, getass)
  collector(addother, getothers) {
    visit:hls3 /rec/ (top: top) {
      deep top {
         module -> mk:node(es = getregwires() :: getrams() :: getass() :: getothers())};
      deep modentry {
         register -> addregwire(node())
       | wire -> addregwire(node())
       | assign -> addass(node())
       | ram -> addram(node())
       | else -> addother(node())}}}}}

\pfcode{
function ll_to_hls_driver_bb(aenv, bb, types) {
   bb2 = ll_to_hls_bb_split(aenv, bb, types);
   // ...
   return bb2;
}}

\pfcode{
function ll_to_hls_driver(top0) {
   top = ll_to_hls_prep_geps(top0);
   typeenv0 = ll_module_types([]);
   types = ll_propagate_types_fun(typeenv0, top);
   aenv = ll_to_hls_prep_memories(top);
   bbs = collector(addbb, getbbs) {
      visit:ir2 (irtoplevel: top) {
         once irbblock {
            bblock -> 
               addbb(ll_to_hls_driver_bb(aenv, node, types))
            }};
      getbbs()};
   getram(nm,t, dims) =
      with target(hls0) {
         mk:ram:r(nm, ll_to_hls_gettype(t), dims)
      };
   nrams = map append r in ohashget(aenv, '*RAMS*') do {
            match r with
              [nm;alloca(t,@dims)] -> [getram(nm, t, dims)]
            | else -> []};
   makearg(nm, tp) = 
      visit:ir2 (irtype: tp) {
         once irtype {
            pointer -> with target(hls0) { mk:modarg:aout(nm, ll_to_hls_gettype(t)) }
          | integer -> with target(hls0) { mk:modarg:ain(nm, ll_to_hls_gettype(tp)) }
          | else -> ccerror('WTF?'(tp))}};
   t1 = visit:ir2 (irtoplevel: top) {
      deep irtoplevel {
         %function -> with target(hls0) {
            nargs = map [tp;nm] in args do makearg(nm, tp);
            mk:top:module(nm = name,
                          rams = nrams, 
                          args = nargs,
                          body = bbs)}
       | else -> ccerror('WTF'())}};

   t1a = ll_to_hls_costmodel(aenv, t1);
   t1b = ll_to_hls_split_loads(aenv, t1a);
   t2  = ll_to_hls_mark_registers(aenv, t1b);
   
   t2a = ll_to_hls_mark_output(aenv, t2);
   t2x = ll_to_hls_lift_wires(t2a);

   h2  = ll_to_hls_explicit_fsms(aenv, t2x);
   h3  = ll_to_hls_remove_phis(h2);
   h4  = ll_to_hls_lower_hls1(h3);
   h4x = ll_to_hls_opt_registers(aenv, h4);
   ret0 = ll_to_hls_lower_fsm(h4x);
   ret2 = ll_to_hls_lower_mems(aenv, ret0);
   
   ret  = ll_to_hls3_sort_decls(ret2);
   return ret}}

\pfcode{include "./ll-hls-backend.hl"}

%%%%%%