A better RISC architecture:


- IFETCH1:
    Increment PC / Forward a PC from DECODE1 / Forward a PC from DECODE2
- IFETCH2:
    Receive an instruction from RAM, set argument register addresses
- DECODE1:
    Receive the register values
- DECODE2:
    Update the register values with forwarding from WB and EX1,
    set up the memory read/write address and WE
- EXEC1:
    Execute the simple operations
- WRITEBACK:
    Receive the memory output
    Setup the writeback addr/value



    
IF1 IF2  DE1 DE2 EX1 WB

                 r3 = add r2, r3
             r4 = add r3, r1
         r2 = add r3, r4

Here, the new R3 value is known at WB,
The new R4 value is not known for 2 more clock cycles,
so the scheduling should be:

   r3 = add r2, r3
   nop
   r4 = add r3, r1
   nop
   r2 = add r2, r4


Some ideas on what to do with the IRQs:

1) We only need an IRQ-enabled configuration for the communication controller core.
   The rest of the Network-on-Chip can do without.
2) We can afford to flush pipeline for an IRQ - as the IRQs will come from a timer (not very precise one),
   UART (100 cycles response latency is ok if FIFO is present), PCIe commands and Ethernet (maybe).

   IRQ handlers themselves are not interruptable, so they must do their dirty work quickly.

   Potential issue here: interrupting before a SELECT instruction (!!!). A workaround would be to
   save the WB state, and reuse it if the next instruction after returning from an IRQ handler is SELECT.
3) Therefore, the only thing we really need to save in hardware is PC and one bit of WB data.



Some thoughts on extension instructions:

  netdef, include, module, reset -> trivial


  inst_exec -> add statements to the exec stage, inside an `if`
      (c2_custom_pipeline.v)
  inst_noreturn -> nothing (make sure the destination reg is R0)
  inst_return ->
      (c2_custom_pipeline.v)

  inst_wait ->
      (c2_custom_idle.v,
       c2_custom_exec.v,
       c2_custom_wait.v)
  
